Overview
========

Design
------

The modules' interface are designed to be functional and clear.  Each function is designed to handle
a specific operation, and do so while producing reproducible results in any invocation; few
*side-effects*.

These modules don't introduce alternative CMake idioms nor do they inhibit using the
CMake language in conjunction with these modules.
Instead, these provide reusable CMake functions helping users follow best practices, and produce
correct, usable CMake based projects.

The largest influences include Daniel Daniel Pfeifer's `Effective
CMake <https://www.youtube.com/watch?v=bsXLMQ6WgIk>`_, Crascit's `Professional
CMake <https://crascit.com/professional-cmake/>`_, and KitWare's `CMake
Documentation <https://cmake.org/cmake/help/latest/index.html>`_.

Many opinionated aspects of projects are enforced. These include target names, project structure,
file naming, and more. Trying to conform to existing projects or alternative designs is not the
goal.

Project Structures
------------------

These modules enforce the `Canonical Project Structure`_.

Certain modules may be used on projects following a different project structure, but this is not
guaranteed.


Using Dependencies
------------------

The provider of dependencies are not defined in CMake, nor do these modules try to define this.
This keeps the project agnostic to C++ package managers, system package managers, etc.

It's recommended that all external requirements are to be found with :cmake:command:`find_package()`
and  linked with :cmake:command:`target_link_libraries()`, but these modules do not prohibit adding
dependencies as subprojects, and *jgd-cmake-modules* supports its consumptions as a subproject.

.. collapse:: Why?

  Acquiring dependencies through :cmake:command:`find_package()` is recommended because it specifies
  the usage requirements of a dependency, and not a series of steps to provide the dependency from a
  specific source. This provides maximum flexibility for future users to provide the dependency in
  whatever manner is most suitable for them, like a package manager. Furthermore, since only usage
  requirements are specified, it's seamless to opt into a direct means of providing the dependency
  such as `FetchContent
  <https://cmake.org/cmake/help/latest/module/FetchContent.html#fetchcontent>`_ or
  :cmake:command:`add_subdirectory()`, to fulfill those needs. `Dependency Providers
  <https://cmake.org/cmake/help/latest/command/cmake_language.html#dependency-providers>`_ is a
  direct mechanism for this. Trying to do the reverse is often more convoluted, even considering
  FetchContent's `find_package integration
  <https://cmake.org/cmake/help/latest/module/FetchContent.html#integrating-with-find-package>`_.

Components
----------

"Component" is a generic term in CMake for project subsets. The term is further refined within
*jgd-cmake-modules*.

Components are *optional* subsets of a project. In the vast majority of cases, these components
represent libraries (one library per component). As an example, a project, *libviewer*, may offer
components *core*, *gtk*, and *qt*, providing the libraries *libviewer-core*, *libviewer-gtk*, and
*libviewer-qt*, respectively.

However, a component may rarely represent an executable. For example, if a project produces multiple
executables that operate together, such as a CLI and a daemon, these may be offered as components of
the same project.

JCM introduces a target property, `COMPONENT`, which the commands
:cmake:command:`jcm_add_executable` and :cmake:command:`jcm_add_library` set to the value provided
to their respective *COMPONENT* arguments. CMake extensively uses `COMPONENT` in function arguments
- this property merely stores the value on the target to be queried throughout JCM.

CMake components refer to what's described in the `Canonical Project Structure`_ as a "family of
libraries". Discussions with its author, Boris Kolpackov, have clarified how the project structure
extends to executable components - the results of which are enforced by *jgd-cmake-modules*.

Prefer separating services, libraries, executables, etc. into individual projects instead of
adding them as components. Use components where appropriate to avoid bloating projects and
complicating their usage.

Target Names
------------

Target names are automatically generated by this library. This is to:

#. Ensure consistency between targets across projects
#. Follow target naming best practices.

    .. collapse:: Target naming practices

      - Since target names within a CMake build must be unique, internal target names should be
        prefixed by the project name to limit naming conflicts. If a project created with these
        modules were to consume another library, or be consumed by another project, the prefixed
        target names ensures uniqueness.
      - exported target names should include ``::`` . Since this is invalid to have in a file path,
        when linking libraries with :cmake:command:`target_link_libraries`, CMake is limited to only
        use CMake target names instead of finding the associated binary on disk, or some other
        binary with the same name. When "linked", CMake targets propagate properties in addition to
        simply linking against a binary, so it's important that targets are used.

#. Allow the exported naming scheme to indicate what the target is and where it came from.

    .. collapse:: Examples

      - Ex. *libcandy::extra* -> the *extra* component of project *libcandy*, whose main purpose is
        to provide a library ( **lib** candy:: )
      - Ex. *cool-shell::cool-shell* -> the main executable of project *cool-shell*, whose main
        purpose is to provide an executable, the shell ( :strike:`lib` cool-shell:: )
      - Ex. *libprotobuf::protobuf-protoc* -> (rare, but supported) an executable component *protoc*
        from a project, *libprotobuf*, that's large enough to mainly provide a library (**lib**
        protobuf::protobuf), while also providing executable components. Here, the executable is
        distributed as a component of the library, instead of as a separate project, because the
        executable is required to use the library.

Exported target naming follows, and is generated by :cmake:command:`jcm_library_naming` and
:cmake:command:`jcm_executable_naming`. Functions, like :cmake:command:`jcm_add_library`, provide
the generated target name through the argument :cmake:`OUT_TARGET`.

+----------------------------------------+---------------------------------------------------------------+
|                                        |                         Project Name                          |
|                                        +-------------------------------+-------------------------------+
|                                        | lib<name>                     | <name>                        |
+=============+==========================+===============================+===============================+
|             | **Library**              | lib<name>::<name>             | <name>::lib<name>             |
| **Created** +--------------------------+-------------------------------+-------------------------------+
|             | **Library Component**    | lib<name>::<component>        | <name>::lib<name>-<component> |
| **Target**  +--------------------------+-------------------------------+-------------------------------+
|             | **Executable**           | lib<name>::<name>             | <name>::<name>                |
|             +--------------------------+-------------------------------+-------------------------------+
|             | **Executable Component** | lib<name>::<name>-<component> | <name>::<component>           |
+-------------+--------------------------+-------------------------------+-------------------------------+

Examples
########

#. In the project `libcandy` (`name` is *candy* in the above table), a main library is created,
   without any :cmake:variable:`COMPONENT` argument. The exported target name will be
   :cmake:`libcandy::libcandy`.

#. In the project `candy` (*name* is *candy* in the above table), a component executable is created
   with the component `wrap`. The exported target name will be :cmake:`candy::wrap`.
