Overview
========

Design
------

The modules' interface are designed to be functional and clear.  Each function is designed to handle
a specific operation, and do so while producing reproducible results in any invocation; few
*side-effects*.

These modules don't introduce alternative CMake idioms nor do they inhibit using the
CMake language in conjunction with these modules.
Instead, these provide reusable CMake functions helping users follow best practices, and produce
correct, usable CMake based projects.

The largest influences include Daniel Daniel Pfeifer's `Effective
CMake <https://www.youtube.com/watch?v=bsXLMQ6WgIk>`_, Crascit's `Professional
CMake <https://crascit.com/professional-cmake/>`_, and KitWare's `CMake
Documentation <https://cmake.org/cmake/help/latest/index.html>`_.

Many opinionated aspects of projects are enforced. These include target names, project structure,
file naming, and more. Trying to conform to existing projects or alternative designs is not the goal.

Project Structures
------------------

These modules enforce the `Canonical Project Structure`_.

Certain modules may be used on projects following a different project structure, but this is not
guaranteed.


Using Dependencies
------------------

The provider of dependencies are not defined in CMake, nor do these modules try to define this.
This keeps the project agnostic to C++ package managers, system package managers, etc.

It's recommended that all external requirements are to be found with :cmake:command:`find_package()`
and :cmake:command:`target_link_libraries()`, but these modules do not prohibit adding dependencies
as subprojects, and *jgd-cmake-modules* supports usage as a subproject.

Components
----------

"Component" is a generic term in CMake for project subsets. It's further refined for our purposes,
here.

Components are *optional* subsets of a project. In the vast majority of cases, these components
represent libraries (one library per component). As an example, a project, *libviewer*, may offer
components *core*, *gtk*, and *qt*, providing the libraries *libviewer-core*, *libviewer-gtk*, and
*libviewer-qt*, respectively.

However, a component may rarely represent an executable. For example, if a project produces multiple
executables that operate together, such as a CLI and a daemon, these may be offered as components.

JCM introduces a target property, `COMPONENT`, which the commands
:cmake:command:`jcm_add_executable` and :cmake:command:`jcm_add_library` set to the value provided
to their respective *COMPONENT* arguments. This property is used throughout JCM to query a target's
component.

CMake components refer to what's described in the `Canonical Project Structure`_ as a "family of
libraries". Discussions with its author, Boris Kolpackov, have clarified how the project structure
extends to executable components - the results of which are enforced by *jgd-cmake-modules*.

Prefer separating services, libraries, executables, etc. into individual projects instead of adding
them as components. Use components where appropriate.

Target Names
------------

Target names are automatically generated by this library. This is to:

#. Ensure consistency between targets across projects
#. Follow target naming best practices. These are:

    - Since target names within a CMake build must be unique, internal target names should be prefixed
      by the project name to limit naming conflicts. If a project created with these modules were to
      consume another library, or be consumed by another project, the prefixed target names ensures
      uniqueness.
    - exported target names should include `::` . Since this is invalid to have in a file path, when
      linking libraries with :cmake:command:`target_link_libraries`, CMake is limited to only use CMake target
      names instead of finding the associated binary on disk, or some other binary with the same name.
      When "linked", CMake targets propagate properties in addition to simply linking against a
      binary, so it's important that targets are used.

#. The export naming scheme immediately indicates what the target is and where it came from.

    Ex. *libcandy::extra* -> the *extra* component of project *libcandy*, which provides a library\
    Ex. *cool-shell::cool-shell* -> the main executable of project *cool-shell*, which provides an executable
    Ex. *libcooking::cooking-planner* -> (rare, but supported) an executable component *planner*
        from a project, *libcooking*, that's large enough to mainly provide a library while also providing
        multiple executable components.

Exported target naming follows. Namespaces are always :cmake:`${PROJECT_NAME}::`.

+--------------------------+---------------------------------------------------------------+
|                          |                         Project Name                          |
+--------------------------+-------------------------------+-------------------------------+
| Created Target           | lib<name>                     | <name>                        |
+==========================+===============================+===============================+
| **Library**              | lib<name>::<name>             | <name>::lib<name>             |
+--------------------------+-------------------------------+-------------------------------+
| **Library Component**    | lib<name>::<component>        | <name>::lib<name>-<component> |
+--------------------------+-------------------------------+-------------------------------+
| **Executable**           | lib<name>::<name>             | <name>::<name>                |
+--------------------------+-------------------------------+-------------------------------+
| **Executable Component** | lib<name>::<name>-<component> | <name>::<component>           |
+--------------------------+-------------------------------+-------------------------------+

Examples
########

#. In the project `libcandy` (`name` is *candy* in the above table), a main library is created, without
   any :cmake:variable:`COMPONENT` argument. The exported target name will be :cmake:`libcandy::libcandy`.

#. In the project `candy` (*name* is *candy* in the above table), a component executable is created
   with the component `wrap`. The exported target name will be :cmake:`candy::wrap`.
