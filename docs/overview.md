# JCM Overview

## Design

The modules' interface are designed to be functional and clear.  Each function is designed to handle
a specific operation, and do so while producing reproducible results in any invocation; few
*side-effects*.

These modules don't introduce alternative CMake idioms nor do they inhibit using the
CMake language in conjunction with these modules.
Instead, these provide reusable CMake functions helping users follow best practices, and produce
correct, usable CMake based projects.

The largest influences include Daniel Daniel Pfeifer's [Effective
CMake](https://www.youtube.com/watch?v=bsXLMQ6WgIk), Crascit's [Professional
CMake](https://crascit.com/professional-cmake/), and KitWare's [CMake
Documentation](https://cmake.org/cmake/help/latest/index.html)

Many opinionated aspects of projects are enforced. These include target names, project structure,
file naming, and more. Trying to conform to existing projects or alternative designs is not the goal.

## Project Structures

These modules enforce the [Canonical Project
Structure](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1204r0.html#:~:text=The%20canonical%20structure%20is%20primarily,specific%20and%20well%2Ddefined%20function.).

Certain modules may be used on projects following a different project structure, but this is not
guaranteed.

## Using Dependencies

The provider of dependencies are not defined in CMake, nor do these modules try to define this.
This keeps the project agnostic to C++ package managers, system package managers, etc.  All external
requirements are to be found with `find_package()` and `target_link_libraries()`, despite this
project supporting usage as a subproject.

## Components

"Component" is a generic term in CMake for project subsets. It's further refined for our purposes,
here.

Components are *optional* subsets of a project. In the vast majority of cases, these components
represent libraries (one library per component). As an example, a project, *libviewer*, may offer
components *core*, *gtk*, and *qt*, providing the libraries *libviewer-core*, *libviewer-gtk*, and
*libviewer-qt*, respectively.

However, a component may rarely represent an executable. For example, if a project produces multiple
executables that operate together, such as a CLI and a daemon, these may be offered as components.

## Target Names

Target names are automatically generated by this library. This is to:

1. Ensure consistency between targets across projects
2. Follow target naming best practices. These are:

    - Since target names within a CMake build must be unique, internal target names should be prefixed
    by the project name to limit naming conflicts. If a project created with these modules were to
    consume another library, or be consumed by another project, the prefixed target names ensures
    uniqueness.
    - exported target names should include `::`. Since this is invalid to have in a file path, when
    linking libraries with `target_link_libraries`, CMake is limited to only use CMake target names
    instead of finding the associated binary on disk, or some other binary with the same name. When
    "linked", CMake targets propagate properties in addition to simply linking against a binary, so it's
    important that targets are used.

3. The naming scheme immediately indicates what the target is and where it came from.

    Ex. *libcandy::extra* -> the *extra* component of project *libcandy*, which provides a library\
    Ex. *cool-shell::cool-shell* -> the main executable of project *cool-shell*, which provides an executable

Exported target naming follows.

**Exported Library Target Names:**

Project Name | Library Target         | Library Component Target
-------------|------------------------|-------------------------
lib\<name\>  | lib\<name>::lib\<name> | lib\<name>::\<component>
<name\>      | \<name>::lib\<name>    | \<name>::lib\<name>-\<component>

**Exported Executable Target Names:**

Project Name | Executable Target   | Executable Component Target
-------------|---------------------|-------------------------
lib\<name\>  | lib\<name>::\<name> | lib\<name>::\<name>-\<component>
<name\>      | \<name>::\<name>    | \<name\>::\<component>
